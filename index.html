<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Transitions Suite (Enhanced Visuals V2 - Fixed Spin)</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500&family=IBM+Plex+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Enhanced CSS Variables --- */
        :root {
            /* General */
            --background-color: #030308; /* Slightly deep blue/black */
            --base-text-color: #e8e8e8;
            --page-glow-opacity: 0.18; /* Slightly more intense base glow */
            --page-glow-color: rgba(100, 120, 200, 0.5); /* Default glow */
            --mouse-x: 50%; /* For reactive glow */
            --mouse-y: 50%; /* For reactive glow */

            /* Spin/Entangled Shared */
            --transition-duration: 1800ms;
            --particle-base-length: 4.8;
            --particle-base-thickness: 1.4;
            --vibration-max-strength: 2.2;
            --particle-glow-blur: 5;
            --particle-glow-opacity: 0.75;
            --rotation-speed-factor: 0.045;
            --secondary-burst-probability: 0.003; /* Probability of a secondary burst per particle per frame */

            /* --- Grid (Entangled & Idle) --- */
            --grid-color: rgba(100, 110, 160, 0.06);
            --grid-spacing: 45px;
            --grid-warp-intensity: 6;
            --idle-grid-warp-intensity: 0.5; /* Much subtler warp for idle state */
            --idle-grid-opacity: 0.04; /* Faint idle grid */

            /* --- Snapping (Entangled) --- */
            --snap-threshold: 0.9;
            --snap-power: 3.5;

            /* Entangled Specific */
            --depth-min-scale: 0.65;
            --depth-max-scale: 1.25;
            --streak-opacity: 0.20;
            --velocity-rotation-factor: 0.009;
            --hue-shift-intensity: 90;
            --saturation-pulse: 0.25;
            --curve-intensity: 0.28;
            --glitch-probability: 0.0004;
            --glitch-displacement: 14px;
            --glitch-color: "#fff0dd";

            /* Spin Specific */
            --particle-length: 4.5;
            --particle-thickness: 1.3;
            --ghost-opacity: 0.15;
            --spin-pulse-color: rgba(255, 255, 255, 0.05);

            /* Decoherence Specific */
            --deco-text-color: #b0b0c0;
            --deco-accent-color: #00bbff;
            --deco-glitch-color-1: #ff33cc;
            --deco-glitch-color-2: #33ffcc;
            --deco-glitch-color-3: #ffee33;
            --deco-grid-color: rgba(0, 187, 255, 0.1);
            --deco-ghost-color: rgba(0, 187, 255, 0.6);
            --corruption-char-pool: "█▓▒░<>{}[]/\\|~$^?#@!*+%&=";
            --corruption-rate: 0.28;
            --corruption-interval: 50ms;
            --deco-glitch-duration: 900ms;
            --deco-burst-duration: 180ms;
            --deco-settle-duration: 450ms;
            --deco-ghost-duration: 500ms;
            --deco-perspective: 1200px;
            --deco-max-3d-rotate: 10deg;
            --deco-max-tear-inset: 22%;
            --deco-max-smear-scale: 25;
            --deco-scanline-opacity: 0.03;
            --deco-datastream-opacity: 0.12;
            --deco-chromatic-offset: 1.5px;
            --deco-block-flash-opacity: 0.08; /* Opacity for block flash overlay */

            /* Idle Animations */
            --idle-text-pulse-opacity: 0.15;
            --idle-jitter-strength: 0.25px; /* Very subtle jitter */
            --orb-size: 6px;
            --orb-color: rgba(180, 200, 255, 0.15);
        }

        /* --- Base & Reset Styles --- */
        *, *::before, *::after { box-sizing: border-box; }
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background-color: var(--background-color); color: var(--base-text-color); font-family: 'Roboto Mono', monospace; position: relative; perspective: var(--deco-perspective); }

        /* --- Background Layers & Effects --- */
        #backgroundCanvas { /* NEW: Canvas for idle effects */
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: -2; /* Below everything except maybe body background */
            pointer-events: none;
        }

        body::before { /* Page Glow - Now reactive */
            content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(ellipse 80% 90% at var(--mouse-x) var(--mouse-y), /* Use CSS vars for position */
                                        transparent 20%,
                                        var(--page-glow-color) 100%);
            opacity: var(--page-glow-opacity);
            mix-blend-mode: soft-light;
            z-index: -1; /* Above bg canvas, below noise */
            pointer-events: none;
            transition: background 1.5s ease-out, --page-glow-color 1.5s ease-out; /* Smooth glow color/position transition */
            will-change: background, --page-glow-color;
        }

        body::after { /* Subtle Noise Overlay */
            content: ""; position: fixed; top: -50%; left: -50%; right: -50%; bottom: -50%; width: 200%; height: 200%;
            background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuOCIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbHRlcj0idXJsKCNub2lzZSkiLz48L3N2Zz4=');
            background-size: 150px 150px;
            opacity: 0.015;
            animation: noiseAnim 15s linear infinite alternate;
            z-index: 0; /* Above glow, below main */
            pointer-events: none;
            will-change: transform;
        }
        @keyframes noiseAnim { 0% { transform: translate(0, 0); } 100% { transform: translate(5%, 10%); } }

        main { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; z-index: 1; /* Ensure main is above overlays */ }

        /* --- General Section Styling --- */
        .section {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; padding: 35px;
            opacity: 0; visibility: hidden;
            transition: opacity 0.2s ease, visibility 0s linear 0.2s;
            pointer-events: none; z-index: 1; user-select: none;
            transform-style: preserve-3d; backface-visibility: hidden;
            clip-path: inset(0% 0% 0% 0%);
            will-change: opacity, transform, clip-path, filter;
        }
        .section.active { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.2s ease, visibility 0s linear 0s; z-index: 2; }
        .section.measuring { z-index: -1; opacity: 0.001; visibility: visible; pointer-events: none; position: fixed; }

        /* --- Headings & Paragraphs --- */
        h1 { font-size: clamp(2rem, 5.5vw, 4rem); margin-bottom: 20px; font-weight: 500; max-width: 85%; text-shadow: 0 0 8px rgba(230, 230, 255, 0.1); position: relative; /* Needed for pseudo-elements potentially */ }
        p { font-size: clamp(0.9rem, 1.9vw, 1.1rem); max-width: 70%; line-height: 1.6; color: #c0c0c8; text-shadow: 0 0 5px rgba(200, 200, 220, 0.05); position: relative; }
        .section-data, .system-colors { display: none; }

        /* --- Transition Canvas Styling --- */
        #transitionCanvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: none; z-index: 10; background-color: transparent; pointer-events: none;
            mix-blend-mode: screen;
        }

        /* === Styles Specific to System Transition === */
        #section-system-1 h1, #section-system-2 h1, #section-system-3 h1 { color: #f0f0f5; }

        /* === Styles Specific to Decoherence Transition === */
        #section-decoherence-1, #section-decoherence-2 {
            max-width: 780px; min-height: 420px; padding: 55px;
            border: 1px solid rgba(0, 187, 255, 0.08);
            background: rgba(20, 20, 35, 0.15);
            backdrop-filter: blur(3px);
            box-shadow: 0 0 25px rgba(0, 187, 255, 0.05);
            font-family: 'IBM Plex Mono', Consolas, Monaco, monospace;
            color: var(--deco-text-color);
            transform-style: preserve-3d;
        }
        /* Pulsing border for active decoherence section */
        #section-decoherence-1.active, #section-decoherence-2.active {
            --current-border-color: rgba(0, 187, 255, 0.1);
            border-color: var(--current-border-color);
            box-shadow: 0 0 25px rgba(0, 187, 255, 0.1), 0 0 10px var(--current-border-color) inset;
        }
        @media (prefers-reduced-motion: no-preference) {
            #section-decoherence-1.active, #section-decoherence-2.active {
                animation: pulseBorder 4s infinite ease-in-out;
            }
        }
        @keyframes pulseBorder {
            0%, 100% { --current-border-color: rgba(0, 187, 255, 0.1); }
            50% { --current-border-color: rgba(0, 187, 255, 0.35); }
        }


        #section-decoherence-1 h1, #section-decoherence-2 h1 {
            font-size: 3rem; margin-bottom: 2rem; color: var(--deco-accent-color); font-weight: 700;
            position: relative; z-index: 3;
            animation: accentPulse 6s infinite cubic-bezier(0.4, 0, 0.6, 1) alternate;
            transform: translateZ(18px);
            text-shadow: 0 0 15px rgba(0, 187, 255, 0.4), 0 0 5px rgba(255, 255, 255, 0.2);
        }
         #section-decoherence-1 p, #section-decoherence-2 p {
            font-size: 1.05rem; margin-bottom: 3.5rem; position: relative; z-index: 3;
            max-width: 75%; transform: translateZ(10px);
             color: var(--deco-text-color); line-height: 1.75;
        }
        .nav-button {
            display: inline-block; padding: 16px 38px; border: 1px solid var(--deco-accent-color);
            color: var(--deco-accent-color); background-color: rgba(0, 187, 255, 0.12);
            text-decoration: none; font-size: 1.05rem; font-family: inherit; cursor: pointer;
            transition: all 0.2s cubic-bezier(0.2, 0.8, 0.2, 1.2);
            z-index: 3; position: relative;
            animation: accentPulse 6s infinite cubic-bezier(0.4, 0, 0.6, 1) alternate; animation-delay: 0.5s;
            transform: translateZ(25px);
            box-shadow: 0 4px 18px rgba(0, 187, 255, 0.25), inset 0 0 5px rgba(0, 187, 255, 0.1);
            text-shadow: 0 0 8px rgba(0, 187, 255, 0.3); border-radius: 3px;
        }
        .nav-button:hover {
            background-color: var(--deco-accent-color); color: var(--background-color);
            transform: translateZ(30px) translateY(-5px) scale(1.03);
            box-shadow: 0 10px 30px rgba(0, 187, 255, 0.5), inset 0 0 8px rgba(255, 255, 255, 0.2);
            text-shadow: none;
        }
        .nav-button:active { transform: translateZ(22px) translateY(-2px) scale(0.95); box-shadow: 0 3px 10px rgba(0, 187, 255, 0.3), inset 0 0 8px rgba(0, 0, 0, 0.2); }

        /* --- Decoherence Overlays --- */
        #glitch-overlay, #color-burst-overlay, #data-stream-overlay, #grid-overlay, #block-flash-overlay { /* Added block-flash */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0; visibility: hidden;
            will-change: opacity, background, visibility, transform;
            z-index: 10; /* Default z-index for overlays */
        }
        #glitch-overlay { background: repeating-linear-gradient( transparent, transparent 1px, rgba(255, 255, 255, var(--deco-scanline-opacity)) 2px, rgba(0, 0, 0, calc(var(--deco-scanline-opacity) * 1.5)) 3px ), repeating-linear-gradient(90deg, rgba(255, 0, 255, 0.02), rgba(0, 255, 255, 0.02) 50%, rgba(255, 0, 255, 0.02) 100%); background-size: 100% 4px, 10px 100%; mix-blend-mode: overlay; z-index: 13; } /* Highest overlay */
        #color-burst-overlay { z-index: 12; background-color: var(--deco-glitch-color-1); mix-blend-mode: color-dodge; }
        #block-flash-overlay { /* NEW */
             z-index: 11; font-family: monospace; font-size: 16px; line-height: 1; color: var(--deco-accent-color);
             white-space: pre; overflow: hidden; text-align: center; display: flex; justify-content: center; align-items: center;
             mix-blend-mode: screen;
             opacity: 0; /* Controlled by class/animation */
         }
        #data-stream-overlay { z-index: 9; font-family: 'IBM Plex Mono', monospace; font-size: 9px; line-height: 1.0; color: rgba(0, 255, 170, 0.4); white-space: pre; overflow: hidden; }
        #grid-overlay { z-index: 8; background-image: linear-gradient(var(--deco-grid-color) 1px, transparent 1px), linear-gradient(90deg, var(--deco-grid-color) 1px, transparent 1px); background-size: 50px 50px; opacity: 0; filter: blur(0.5px); }

        /* --- Decoherence State Classes & Animations --- */
        body.transitioning-decoherence #glitch-overlay { visibility: visible; opacity: 0.5; animation: scanlines calc(var(--deco-glitch-duration) / 15) infinite linear, glitchFlicker 0.5s infinite steps(1, end); }
        body.transitioning-decoherence #color-burst-overlay { visibility: visible; opacity: 0; animation: colorBurst var(--deco-burst-duration) steps(5, end) forwards; animation-delay: calc(var(--deco-glitch-duration) - var(--deco-burst-duration) * 1.1); }
        body.transitioning-decoherence #data-stream-overlay { visibility: visible; opacity: var(--deco-datastream-opacity); animation: dataStreamScroll calc(var(--deco-glitch-duration) * 0.8) linear infinite; }
        body.transitioning-decoherence #grid-overlay { visibility: visible; animation: gridDistort var(--deco-glitch-duration) ease-in-out forwards; }
        /* Activate block flash during glitch */
        body.transitioning-decoherence #block-flash-overlay.active {
             visibility: visible;
             opacity: var(--deco-block-flash-opacity);
             animation: blockFlash 0.08s steps(1, end) infinite;
         }
        @keyframes blockFlash { 0%, 100% { opacity: 0; } 50% { opacity: var(--deco-block-flash-opacity); } }

        /* Glitching State (Outgoing Section) */
        .section.glitching { z-index: 1; opacity: 1 !important; visibility: visible !important; animation: section3D var(--deco-glitch-duration) cubic-bezier(0.3, 0, 0.7, 1) forwards, sectionTear var(--deco-glitch-duration) steps(10, end) forwards, screenShake 0.1s 4 linear alternate; will-change: transform, clip-path, filter; }
        .section.glitching h1, .section.glitching p, .section.glitching .nav-button { text-shadow: var(--deco-chromatic-offset) 0 0 rgba(255, 0, 0, 0.5), calc(var(--deco-chromatic-offset) * -1) 0 0 rgba(0, 255, 255, 0.5), 0 0 15px rgba(0, 187, 255, 0.4), 0 0 5px rgba(255, 255, 255, 0.2); animation: textFlicker 0.15s infinite alternate; will-change: text-shadow, filter; }

        /* Settling State (Incoming Section) */
        .section.settling { animation: scaleSettle var(--deco-settle-duration) cubic-bezier(0.1, 1.5, 0.3, 1) forwards; will-change: transform, opacity, filter; }

        /* Ghosting State (Outgoing Section after Glitch) */
        .section.ghosting { z-index: 0; pointer-events: none; animation: ghostFadeSmear var(--deco-ghost-duration) ease-in-out forwards; filter: none; color: var(--deco-ghost-color); will-change: transform, opacity, filter, clip-path, color; }
        .section.ghosting h1, .section.ghosting p, .section.ghosting .nav-button { text-shadow: none; animation: none; color: inherit; }


        /* --- Keyframes (Includes Existing & New Idle/Decoherence) --- */
        @keyframes scanlines { 0% { background-position: 0 0, 0 0; } 100% { background-position: 0 4px, 5px 0; } }
        @keyframes glitchFlicker { 0%, 100% { opacity: 0.4; } 50% { opacity: 0.6; } }
        @keyframes textFlicker { 0% { filter: brightness(1); } 100% { filter: brightness(0.9) saturate(0.8); } }
        @keyframes accentPulse { from { filter: brightness(0.8) saturate(0.8); text-shadow: 0 0 12px rgba(0, 187, 255, 0.2); } to { filter: brightness(1.2) saturate(1.2); text-shadow: 0 0 20px rgba(0, 187, 255, 0.5), 0 0 5px rgba(255, 255, 255, 0.2); } }
        @keyframes colorBurst { 0% { background-color: var(--deco-glitch-color-1); opacity: 0; } 20% { opacity: 0.8; } 40% { background-color: var(--deco-glitch-color-2); opacity: 0.9; } 60% { background-color: var(--deco-glitch-color-3); opacity: 0.85; } 80% { background-color: #ffffff; opacity: 0.6; } 100% { opacity: 0; } }
        @keyframes dataStreamScroll { from { transform: translateY(0%); } to { transform: translateY(-50%); } }
        @keyframes gridDistort { 0% { opacity: 0; background-size: 50px 50px; transform: skew(0deg) scale(1); filter: blur(0.5px); } 10% { opacity: 0.6; filter: blur(0px); } 30% { opacity: 0.4; background-size: 45px 55px; transform: skew(-4deg, 3deg) scale(1.04); } 50% { opacity: 0.7; background-size: 60px 40px; } 70% { opacity: 0.3; background-size: 52px 52px; transform: skew(3deg, -5deg) scale(0.98); filter: blur(1px); } 90% { opacity: 0.5; } 100% { opacity: 0; background-size: 50px 50px; transform: skew(0deg) scale(1); visibility: hidden; filter: blur(0.5px); } }
        @keyframes section3D { 0%, 100% { transform: rotateX(0) rotateY(0) rotateZ(0) scale(1); } 25% { transform: rotateX(calc(var(--deco-max-3d-rotate) * -1.1)) rotateY(calc(var(--deco-max-3d-rotate) * 0.8)) rotateZ(-1.8deg) scale(0.97); } 50% { transform: rotateX(calc(var(--deco-max-3d-rotate) * 0.7)) rotateY(calc(var(--deco-max-3d-rotate) * -1.2)) rotateZ(2.5deg) scale(1.02); } 75% { transform: rotateX(calc(var(--deco-max-3d-rotate) * 1.2)) rotateY(calc(var(--deco-max-3d-rotate) * 0.4)) rotateZ(-2.0deg) scale(0.98); } }
        @keyframes sectionTear { 0%, 100% { clip-path: inset(0% 0% 0% 0%); } 15% { clip-path: polygon(0 0, 100% var(--deco-max-tear-inset), 100% 100%, 0 calc(100% - var(--deco-max-tear-inset))); } 30% { clip-path: inset(var(--deco-max-tear-inset) 4% 12% calc(var(--deco-max-tear-inset))); } 45% { clip-path: polygon(calc(var(--deco-max-tear-inset) * 0.8) var(--deco-max-tear-inset), 100% 0, calc(100% - var(--deco-max-tear-inset)) 100%, 0% calc(100% - var(--deco-max-tear-inset))); } 60% { clip-path: inset(10% calc(var(--deco-max-tear-inset)*1.2) 5% 5%); } 75% { clip-path: polygon(0% var(--deco-max-tear-inset), calc(100% - var(--deco-max-tear-inset)) var(--deco-max-tear-inset), 100% 100%, var(--deco-max-tear-inset) calc(100% - 5%)); } 90% { clip-path: inset(5% 5% var(--deco-max-tear-inset) calc(var(--deco-max-tear-inset)*0.9)); } }
        @keyframes scaleSettle { 0% { transform: scale(1.3) translateZ(0); opacity: 0; filter: brightness(1.6) blur(1px); } 60% { transform: scale(0.95) translateZ(0); opacity: 1; filter: brightness(1) blur(0); } 80% { transform: scale(1.03) translateZ(0); } 95% { transform: scale(0.99) translateZ(0); } 100% { transform: scale(1) translateZ(0); opacity: 1; filter: brightness(1) blur(0); } }
        @keyframes ghostFadeSmear { 0% { opacity: 0.8; filter: blur(0.8px) saturate(1.2); transform: scale(1.01); color: var(--deco-ghost-color); clip-path: inset(0% 0% 0% 0%); } 30% { transform: scale(1.02) scaleY(1.3); clip-path: inset(0 30% 0 30%); } 60% { opacity: 0.5; filter: blur(3px) saturate(1.5); transform: scale(0.98) scaleX(1.5); clip-path: inset(30% 0 30% 0); color: var(--deco-ghost-color); } 85% { opacity: 0.15; filter: blur(6px) saturate(1.0); transform: scale(0.96); clip-path: inset(40% 40% 40% 40%); } 100% { opacity: 0; filter: blur(12px) saturate(0); transform: scale(0.94); visibility: hidden; color: var(--deco-ghost-color); clip-path: inset(50% 50% 50% 50%); } }
        @keyframes screenShake { 0%, 100% { transform: translate(0, 0) rotate(0); } 25% { transform: translate(2px, -1px) rotate(-0.2deg); } 50% { transform: translate(-2px, 1px) rotate(0.1deg); } 75% { transform: translate(1px, 2px) rotate(0.2deg); } }

        /* --- NEW Idle Animations --- */
        @keyframes textPulseGlow { /* Subtle glow pulse for active text */
            0%, 100% { text-shadow: 0 0 8px rgba(230, 230, 255, 0.1); }
            50% { text-shadow: 0 0 14px rgba(230, 230, 255, var(--idle-text-pulse-opacity)); }
        }
        @keyframes quantumJitter { /* Subtle position jitter for active text */
             0%, 100% { transform: translate(calc(var(--idle-jitter-strength) * 0.4), calc(var(--idle-jitter-strength) * -0.8)); }
             25% { transform: translate(calc(var(--idle-jitter-strength) * -1.2), calc(var(--idle-jitter-strength) * 0.4)); }
             50% { transform: translate(calc(var(--idle-jitter-strength) * 0.8), calc(var(--idle-jitter-strength) * 1.2)); }
             75% { transform: translate(calc(var(--idle-jitter-strength) * -0.4), calc(var(--idle-jitter-strength) * -0.4)); }
        }
        @keyframes drift { /* For floating orbs */
             from { transform: translate(var(--tx1), var(--ty1)) rotate(0deg) scale(var(--s1)); }
             to   { transform: translate(var(--tx2), var(--ty2)) rotate(360deg) scale(var(--s2)); }
        }

        /* Apply idle animations conditionally based on motion preference */
        @media (prefers-reduced-motion: no-preference) {
            .section.active:not(.glitching):not(.ghosting):not(.settling) h1, /* Apply only when idle */
            .section.active:not(.glitching):not(.ghosting):not(.settling) p {
                 animation: textPulseGlow 6s infinite ease-in-out, quantumJitter 9s infinite linear alternate;
             }
             .section:not(.glitching):not(.ghosting):not(.settling) h1:hover { /* Subtle hover on non-transitioning text */
                 filter: brightness(1.1);
                 text-shadow: 0 0 12px rgba(230, 230, 255, 0.2);
             }
             .floating-orb {
                 animation: drift 25s infinite ease-in-out alternate;
             }
             body::before { /* Only animate glow shift if no motion preference */
                animation: glowShift 25s infinite ease-in-out alternate;
             }
             @keyframes glowShift { /* Slowly shift the radial gradient center slightly */
                from { --mouse-x: 45%; --mouse-y: 48%; }
                to   { --mouse-x: 55%; --mouse-y: 52%; }
             }
        }

        /* --- Floating Orbs --- */
        .floating-orb {
             position: fixed; /* Fixed position relative to viewport */
             width: var(--orb-size); height: var(--orb-size);
             background-color: var(--orb-color);
             border-radius: 50%;
             filter: blur(calc(var(--orb-size) / 4));
             z-index: 0; /* Above background, below main content */
             pointer-events: none;
             opacity: 0.6;
             will-change: transform; /* Hint for animation */
         }
         /* Define random start/end positions and scales for orbs */
         #orb1 { top: 15%; left: 10%; --tx1: 0vw; --ty1: 0vh; --tx2: 5vw; --ty2: -8vh; --s1: 0.9; --s2: 1.1; animation-duration: 32s; }
         #orb2 { bottom: 10%; right: 12%; --tx1: 0vw; --ty1: 0vh; --tx2: -6vw; --ty2: 4vh; --s1: 1.2; --s2: 0.8; animation-duration: 28s; animation-delay: -5s; }
          /* Add more orbs as desired */

    </style>
</head>
<body>
    <!-- Background Canvas for Idle Effects -->
    <canvas id="backgroundCanvas"></canvas>

    <!-- Overlays for Decoherence -->
    <div id="glitch-overlay"></div>
    <div id="color-burst-overlay"></div>
    <div id="data-stream-overlay"></div>
    <div id="grid-overlay"></div>
    <div id="block-flash-overlay"></div> <!-- New Overlay -->

    <main> <!-- Main wrapper -->
         <!-- Floating Orbs -->
         <div class="floating-orb" id="orb1"></div>
         <div class="floating-orb" id="orb2"></div>

        <!-- Sections Group 0: System -->
        <div id="section-system-1" class="section active">
            <h1>System State Alpha</h1>
            <p>Scroll slowly to get best out of transition.</p>
            <span class="system-colors" data-color1="#ff00ff" data-color2="#aa00aa" data-glow="rgba(255, 50, 255, 0.6)"></span>
        </div>
        <div id="section-system-2" class="section">
            <h1>System State Beta</h1>
            <p>Transitioning through Hilbert space to a new configuration.</p>
             <span class="system-colors" data-color1="#00ffff" data-color2="#00aaaa" data-glow="rgba(50, 255, 255, 0.6)"></span>
        </div>
        <div id="section-system-3" class="section">
            <h1>Coherent Superposition</h1>
            <p>A delicate balance of multiple states existing simultaneously.</p>
             <span class="system-colors" data-color1="#ffff00" data-color2="#aaaa00" data-glow="rgba(255, 255, 50, 0.6)"></span>
        </div>

        <!-- Sections Group 1: Entangled -->
        <div id="section-entangled-1" class="section">
            <h1>Entangled Genesis</h1>
            <p>Paired particles originating from a single quantum event, linked instantaneously.</p>
            <div class="section-data" data-color1="#ff99dd" data-color2="#ee77cc" data-glow="rgba(255, 153, 221, 0.7)"></div>
        </div>
        <div id="section-entangled-2" class="section">
            <h1>Spooky Action</h1>
            <p>Measurement on one particle instantaneously reveals the correlated state of its distant partner.</p>
            <div class="section-data" data-color1="#99ddff" data-color2="#77ccee" data-glow="rgba(153, 221, 255, 0.7)"></div>
        </div>
        <div id="section-entangled-3" class="section">
            <h1>Quantum Measurement</h1>
            <p>The very act of observation collapses the wave function, defining a specific reality.</p>
            <div class="section-data" data-color1="#ddff99" data-color2="#ccee77" data-glow="rgba(221, 255, 153, 0.7)"></div>
        </div>

        <!-- Sections Group 2: Spin -->
        <div id="section-spin-1" class="section">
            <h1>Spin Up State |↑⟩</h1>
            <p>A fundamental quantum property measured along a specific axis.</p>
            <div class="section-data" data-color1="#ff77ff" data-color2="#dd55dd" data-glow="rgba(255, 119, 255, 0.65)"></div>
        </div>
        <div id="section-spin-2" class="section">
            <h1>Spin Superposition</h1>
            <p>Existing in a probabilistic combination of Up and Down states until measured.</p>
            <div class="section-data" data-color1="#77ffff" data-color2="#55dddd" data-glow="rgba(119, 255, 255, 0.65)"></div>
        </div>
        <div id="section-spin-3" class="section">
            <h1>Spin Down State |↓⟩</h1>
            <p>The complementary quantum state, definite upon measurement.</p>
            <div class="section-data" data-color1="#ffff77" data-color2="#dddd55" data-glow="rgba(255, 255, 119, 0.65)"></div>
        </div>

         <!-- Sections Group 3: Decoherence -->
         <section id="section-decoherence-1" class="section">
            <h1 data-text="Decoherence">Decoherence</h1>
            <p data-text="Environmental interaction collapses superposition. Quantum fragility yields the classical world we perceive.">
                Environmental interaction collapses superposition. Quantum fragility yields the classical world we perceive.
            </p>
            <button class="nav-button" data-target="#section-decoherence-2" data-text="Isolate System">Isolate System</button>
        </section>
        <section id="section-decoherence-2" class="section">
            <h1 data-text="Quantum Coherence">Quantum Coherence</h1>
            <p data-text="Careful isolation preserves superposition. Quantum information remains intact, potential unlocked.">
               Careful isolation preserves superposition. Quantum information remains intact, potential unlocked.
            </p>
            <button class="nav-button" data-target="#section-decoherence-1" data-text="Expose to Environment">Expose to Environment</button>
        </section>

    </main>

    <!-- Transition Canvas (used by System, Entangled, Spin) -->
    <canvas id="transitionCanvas"></canvas>

    <script>
        // --- Global State ---
        const allSections = document.querySelectorAll('.section');
        const transitionCanvas = document.getElementById('transitionCanvas');
        const transitionCtx = transitionCanvas.getContext('2d', { alpha: true, desynchronized: true });
        const backgroundCanvas = document.getElementById('backgroundCanvas'); // New BG Canvas
        const bgCtx = backgroundCanvas.getContext('2d', { alpha: true, desynchronized: true }); // New BG Context
        const body = document.body;
        const mainElement = document.querySelector('main');
        const blockFlashOverlay = document.getElementById('block-flash-overlay');

        const effectTypes = ['system', 'entangled', 'spin', 'decoherence'];
        const sectionsPerEffect = [
            [document.getElementById('section-system-1'), document.getElementById('section-system-2'), document.getElementById('section-system-3')],
            [document.getElementById('section-entangled-1'), document.getElementById('section-entangled-2'), document.getElementById('section-entangled-3')],
            [document.getElementById('section-spin-1'), document.getElementById('section-spin-2'), document.getElementById('section-spin-3')],
            [document.getElementById('section-decoherence-1'), document.getElementById('section-decoherence-2')]
        ];
        const totalEffects = effectTypes.length;
        let currentEffectIndex = 0;
        let currentSectionIndexInEffect = 0;
        let isAnimating = false; // Tracks if a *transition* is animating
        let transitionAnimationFrameId = null;
        let idleAnimationFrameId = null; // Separate ID for idle animation loop
        let transitionStartTime = 0;

        const textPixelDataCache = new Map();
        let lastCanvasWidth = 0;
        let lastCanvasHeight = 0;
        let currentFrameCSSVars = {}; // Cache CSS vars per transition frame

        // Motion Preference Check
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // Smoother noise function
        const noise = { seed: Math.random(), detail: (x, y) => (Math.sin(x * 0.08 + noise.seed * 1.15) + Math.cos(y * 0.08 + noise.seed * 1.25)) * 0.5 + 0.5 };

        // --- Idle Animation State ---
        let bgParticles = [];
        const NUM_BG_PARTICLES = prefersReducedMotion ? 20 : 80;
        const BG_PARTICLE_SPEED = 0.2;
        const BG_PARTICLE_SIZE = 1.5;
        let cursorTrailParticles = [];
        const CURSOR_TRAIL_LENGTH = prefersReducedMotion ? 0 : 15;
        const CURSOR_TRAIL_FADEOUT = 0.06;
        let mousePos = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let lastMouseUpdate = 0;
        const MOUSE_UPDATE_THROTTLE = 16; // ~60fps throttle

        // --- Helpers ---
        function lerp(a, b, t) { return a + (b - a) * t; }
        function easeInOutCubic(t) { return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2; }
        function easeInOutQuad(t) { return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; }
        function parseHexColor(hex) { hex = hex.slice(1); if (hex.length === 3) hex = hex.split('').map(c => c + c).join(''); return [parseInt(hex.slice(0, 2), 16), parseInt(hex.slice(2, 4), 16), parseInt(hex.slice(4, 6), 16)]; };
        function lerpColorRGB(hex1, hex2, t) { const [r1, g1, b1] = parseHexColor(hex1); const [r2, g2, b2] = parseHexColor(hex2); const r = Math.round(lerp(r1, r2, t)); const g = Math.round(lerp(g1, g2, t)); const b = Math.round(lerp(b1, b2, t)); return `rgb(${r},${g},${b})`; }
        function hexToHsl(hex) { hex = hex.slice(1); if (hex.length === 3) hex = hex.split('').map(c => c + c).join(''); let r = parseInt(hex.slice(0, 2), 16) / 255; let g = parseInt(hex.slice(2, 4), 16) / 255; let b = parseInt(hex.slice(4, 6), 16) / 255; let max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if (max == min) { h = s = 0; } else { let d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return { h: h * 360, s: s, l: l }; }
        function hslToRgbString(h, s, l, a = 1) { let r, g, b; if (s == 0) { r = g = b = l; } else { const hue2rgb = (p, q, t) => { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1 / 6) return p + (q - p) * 6 * t; if (t < 1 / 2) return q; if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6; return p; }; let q = l < 0.5 ? l * (1 + s) : l + s - l * s; let p = 2 * l - q; h /= 360; r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3); } return `rgba(${Math.round(r * 255)}, ${Math.round(g * 255)}, ${Math.round(b * 255)}, ${a})`; }

        // --- Cache CSS ---
        function cacheCSSVars(varNames) {
            const styles = getComputedStyle(document.documentElement);
            const cached = {};
            varNames.forEach(name => {
                const value = styles.getPropertyValue(name).trim();
                const floatVal = parseFloat(value);
                cached[name] = !isNaN(floatVal) && value.match(/^[+-]?\d+(\.\d+)?(px|ms|deg|%|em|rem|vw|vh)?$/i) ? floatVal : value;
            });
            return cached;
        }

        // --- Text Pixel Data (Optimized Cache Check) ---
        function getTextPixelData(sectionElement, particleBaseLength, particleBaseThickness, particleDensity = 0.7, maxParticles = 8000) {
             const sectionId = sectionElement.id;
             if (textPixelDataCache.has(sectionId) && transitionCanvas.width === lastCanvasWidth && transitionCanvas.height === lastCanvasHeight) {
                 return textPixelDataCache.get(sectionId);
             }

             const pixelData = [];
             const h1 = sectionElement.querySelector('h1');
             const p = sectionElement.querySelector('p');
             const dataEl = sectionElement.querySelector('.section-data') || sectionElement.querySelector('.system-colors');
             if (!h1 || !p || !dataEl) { console.warn("Missing elements in section:", sectionId); return []; }
             const data = dataEl.dataset;

             sectionElement.classList.add('measuring'); sectionElement.offsetHeight;

             const h1Style = getComputedStyle(h1); const pStyle = getComputedStyle(p);
             const h1Rect = h1.getBoundingClientRect(); const pRect = p.getBoundingClientRect();

             sectionElement.classList.remove('measuring');

             // Use the *transition* canvas context for sampling
             transitionCtx.clearRect(0, 0, transitionCanvas.width, transitionCanvas.height);

             transitionCtx.font = h1Style.font; transitionCtx.fillStyle = data.color1 || '#ffffff';
             transitionCtx.textAlign = 'center'; transitionCtx.textBaseline = 'middle';
             const h1Lines = wrapText(transitionCtx, h1.textContent || '', h1Rect.left + h1Rect.width / 2, h1Rect.width, parseFloat(h1Style.fontSize) * 1.2);
             let currentH1Y = h1Rect.top + h1Rect.height / 2 - (h1Lines.length - 1) * parseFloat(h1Style.fontSize) * 0.6;
             h1Lines.forEach(line => { transitionCtx.fillText(line.text, line.x, currentH1Y); currentH1Y += line.lineHeight; });

             transitionCtx.font = pStyle.font; transitionCtx.fillStyle = data.color2 || '#cccccc';
             transitionCtx.textAlign = 'center'; transitionCtx.textBaseline = 'top';
             const pLines = wrapText(transitionCtx, p.textContent || '', pRect.left + pRect.width / 2, pRect.width, parseFloat(pStyle.lineHeight) || (parseFloat(pStyle.fontSize) * 1.5));
             let currentPY = pRect.top;
             pLines.forEach(line => { transitionCtx.fillText(line.text, line.x, currentPY); currentPY += line.lineHeight; });

             try {
                 const imageData = transitionCtx.getImageData(0, 0, transitionCanvas.width, transitionCanvas.height);
                 const imgData = imageData.data;
                 const step = Math.max(2, Math.floor(Math.sqrt(particleBaseLength * particleBaseThickness) / (particleDensity * 0.75) ));

                 for (let y = 0; y < transitionCanvas.height; y += step) {
                     for (let x = 0; x < transitionCanvas.width; x += step) {
                         const index = (y * transitionCanvas.width + x) * 4;
                         const alpha = imgData[index + 3];
                         if (alpha > 80 && pixelData.length < maxParticles) {
                             const r = imgData[index]; const g = imgData[index + 1]; const b = imgData[index + 2];
                             const color = `rgb(${r},${g},${b})`;
                             pixelData.push({ x, y, color });
                         }
                     }
                 }
              } catch (e) { console.error("Error getting ImageData:", e); }

             transitionCtx.clearRect(0, 0, transitionCanvas.width, transitionCanvas.height); // Clear canvas after sampling
             textPixelDataCache.set(sectionId, pixelData);
             lastCanvasWidth = transitionCanvas.width; lastCanvasHeight = transitionCanvas.height;
             return pixelData;
         }

        // Helper for simple text wrapping
        function wrapText(context, text, x, maxWidth, lineHeight) {
            const words = text.split(' '); let line = ''; const lines = [];
            for(let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' '; const metrics = context.measureText(testLine); const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) { lines.push({ text: line.trim(), x: x, lineHeight: lineHeight }); line = words[n] + ' '; }
                else { line = testLine; }
            }
            lines.push({ text: line.trim(), x: x, lineHeight: lineHeight }); return lines;
        }

        // --- Secondary Burst Effect (Defined but not used by Spin) ---
        let secondaryBursts = []; // Stores { x, y, radius, alpha, color }
        const BURST_MAX_RADIUS = 25;
        const BURST_FADE_SPEED = 0.08;

        function createBurst(x, y, color) {
            secondaryBursts.push({ x, y, radius: 0, alpha: 0.6, color });
        }

        function drawBursts(ctx) {
            for (let i = secondaryBursts.length - 1; i >= 0; i--) {
                const burst = secondaryBursts[i];
                burst.radius += 1.5; // Expand speed
                burst.alpha -= BURST_FADE_SPEED;

                if (burst.alpha <= 0) {
                    secondaryBursts.splice(i, 1);
                    continue;
                }

                ctx.beginPath();
                ctx.arc(burst.x, burst.y, burst.radius, 0, Math.PI * 2);
                ctx.fillStyle = burst.color.replace('rgb', 'rgba').replace(')', `, ${burst.alpha.toFixed(2)})`);
                ctx.fill();
            }
        }


        // --- EFFECT 0: System Transition ---
        let systemParticles = [];
        const systemTransitionDuration = 800;
        const systemParticleDensity = 0.004;
        const systemMaxOffset = 80;

        function setupSystemEffect(fromSection, toSection) {
            document.documentElement.style.setProperty('--transition-duration', `${systemTransitionDuration}ms`);
            resizeTransitionCanvas(); // Use specific resize function
            transitionCanvas.style.backgroundColor = '#000';
            transitionCanvas.style.mixBlendMode = 'normal';
            transitionCanvas.style.display = 'block';
            updatePageGlow(toSection);

            const outgoingColorElement = fromSection.querySelector('.system-colors') || fromSection.querySelector('.section-data');
            const outgoingColors = outgoingColorElement ? outgoingColorElement.dataset : { color1: '#ffffff', color2: '#808080' };
            const incomingColorElement = toSection.querySelector('.system-colors') || toSection.querySelector('.section-data');
            const incomingColors = incomingColorElement ? incomingColorElement.dataset : { color1: '#ffffff', color2: '#808080' };

            const currentIndex = Array.from(allSections).indexOf(fromSection);
            const nextIndex = Array.from(allSections).indexOf(toSection);
            window.systemIsScrollingDown = nextIndex > currentIndex || (nextIndex === 0 && currentIndex === allSections.length - 1);

            systemParticles = [];
            const numParticles = Math.floor(transitionCanvas.width * transitionCanvas.height * systemParticleDensity);
             for (let i = 0; i < numParticles; i++) {
                 const baseX = (i / numParticles) * transitionCanvas.width + Math.random() * 8 - 4;
                 const baseY = Math.random() * transitionCanvas.height;
                 const noiseVal = noise.detail(baseX * 0.5, baseY * 0.5);
                 systemParticles.push({ baseX, baseY, noiseVal, outgoingColors, incomingColors });
             }

            transitionStartTime = 0;
            if (transitionAnimationFrameId) cancelAnimationFrame(transitionAnimationFrameId);
            transitionAnimationFrameId = requestAnimationFrame(animateSystem);
        }

        function animateSystem(timestamp) {
            if (!transitionStartTime) transitionStartTime = timestamp;
            const elapsed = timestamp - transitionStartTime;
            let progress = Math.min(elapsed / systemTransitionDuration, 1);
            progress = easeInOutQuad(progress);

            transitionCtx.fillStyle = '#000';
            transitionCtx.fillRect(0, 0, transitionCanvas.width, transitionCanvas.height);

            const scrollDir = window.systemIsScrollingDown ? 1 : -1;
            const invProgress = 1 - progress;

            for (let i = 0; i < systemParticles.length; i++) {
                const p = systemParticles[i];
                let shouldDraw = false; let drawX = p.baseX; let drawSize = 0; let drawColor = null;

                if (p.noiseVal < invProgress * 0.85) {
                     drawColor = Math.random() > 0.5 ? p.outgoingColors.color1 : p.outgoingColors.color2;
                     drawX += -scrollDir * systemMaxOffset * progress * (p.noiseVal * 2 - 1);
                     drawSize = (1 + p.noiseVal) * invProgress * 1.8;
                     shouldDraw = true;
                }
                 if (p.noiseVal < progress * 0.85) {
                     drawColor = Math.random() > 0.5 ? p.incomingColors.color1 : p.incomingColors.color2;
                     const incomingOffsetX = scrollDir * systemMaxOffset * invProgress * (p.noiseVal * 2 - 1);
                     drawX = p.baseX + incomingOffsetX;
                     drawSize = (1 + p.noiseVal) * progress * 1.8;
                     shouldDraw = true;
                 }
                 if (shouldDraw && drawSize > 0.5 && drawColor) {
                     transitionCtx.fillStyle = drawColor;
                     transitionCtx.fillRect(drawX, p.baseY, drawSize, drawSize);
                 }
            }

            if (progress < 1) {
                transitionAnimationFrameId = requestAnimationFrame(animateSystem);
            } else {
                completeTransition();
            }
        }


        // --- EFFECT 1: Entangled Transition ---
        let entangledParticles = [];
        const entangledTransitionDuration = 1800;
        const entangledParticleDensity = 0.7;
        const entangledMaxParticles = 7000;

        const entangledCSSVarNames = [
            '--depth-max-scale', '--depth-min-scale', '--particle-base-length', '--particle-base-thickness',
            '--curve-intensity', '--snap-threshold', '--snap-power', '--glitch-probability',
            '--glitch-displacement', '--hue-shift-intensity', '--saturation-pulse', '--vibration-max-strength',
            '--velocity-rotation-factor', '--rotation-speed-factor', '--glitch-color', '--streak-opacity',
            '--particle-glow-blur', '--particle-glow-opacity', '--grid-color', '--grid-spacing', '--grid-warp-intensity',
             '--secondary-burst-probability' // Still used by Entangled
        ];

        class EntangledParticle {
             constructor(x, y, color, cssVars) {
                 this.initialX = x; this.initialY = y; this.initialColor = hexToHsl(color);
                 this.currentX = x; this.currentY = y; this.currentColor = this.initialColor;
                 this.targetX = x; this.targetY = y; this.targetColor = this.initialColor;
                 this.vx = 0; this.vy = 0; this.travelDistance = 0; this.rotation = Math.random() * Math.PI * 2;
                 this.rotationSpeed = 0; this.isPaired = false; this.hueShiftDirection = 1;
                 this.prevX = x; this.prevY = y; this.controlX = x; this.controlY = y; this.currentSpeed = 0;
                 this.depthFactor = Math.random() * (cssVars['--depth-max-scale'] - cssVars['--depth-min-scale']) + cssVars['--depth-min-scale'];
                 this.length = cssVars['--particle-base-length'] * this.depthFactor;
                 this.thickness = cssVars['--particle-base-thickness'] * this.depthFactor;
                 this.isGlitching = false; this.glitchFrames = 0;
                 this.baseGlowOpacity = cssVars['--particle-glow-opacity'];
                 this.radius = this.thickness / 3;
            }
            assignTarget(targetX, targetY, targetColorHex, cssVars) {
                 this.targetX = targetX; this.targetY = targetY; this.targetColor = hexToHsl(targetColorHex);
                 const dx = this.initialX - this.targetX; const dy = this.initialY - this.targetY; this.travelDistance = Math.sqrt(dx * dx + dy * dy);
                 const midX = (this.initialX + this.targetX) / 2; const midY = (this.initialY + this.targetY) / 2; const angle = Math.atan2(dy, dx); const perpAngle = angle + Math.PI / 2;
                 const curveIntensity = cssVars['--curve-intensity'];
                 const offset = this.travelDistance * curveIntensity * (Math.random() > 0.5 ? 1 : -1);
                 this.controlX = midX + Math.cos(perpAngle) * offset; this.controlY = midY + Math.sin(perpAngle) * offset;
            }
            setPairProperties(speed, hueDir) { if (!this.isPaired) { this.rotationSpeed = speed * this.depthFactor; this.hueShiftDirection = hueDir; this.isPaired = true; } }
            update(progress, cssVars) { // Includes burst trigger for Entangled
                 this.prevX = this.currentX; this.prevY = this.currentY;
                 const t = easeInOutCubic(progress);
                 const { '--snap-threshold': snapThreshold, '--snap-power': snapPower, '--glitch-probability': glitchProbability, '--glitch-displacement': glitchDisplacement, '--hue-shift-intensity': hueShiftIntensity, '--saturation-pulse': saturationPulse, '--vibration-max-strength': vibrationMaxStrength, '--velocity-rotation-factor': velocityRotationFactor, '--secondary-burst-probability': burstProb } = cssVars;
                 const snapFactor = progress > snapThreshold ? Math.max(0, 1 - Math.pow((progress - snapThreshold) / (1 - snapThreshold), snapPower)) : 1.0;

                 this.isGlitching = false;
                 if (this.glitchFrames > 0) { this.isGlitching = true; this.glitchFrames--; }
                 else if (snapFactor > 0.1 && Math.random() < glitchProbability) { this.isGlitching = true; this.glitchFrames = Math.floor(Math.random() * 3) + 1; }

                 const midTransitionFactor = Math.sin(Math.PI * progress);
                 let currentHue = lerp(this.initialColor.h, this.targetColor.h, t);
                 const hueShiftMagnitude = midTransitionFactor * hueShiftIntensity * Math.sin(progress * Math.PI * 2.5) * snapFactor;
                 currentHue = (currentHue + hueShiftMagnitude * this.hueShiftDirection + 360) % 360;
                 let currentSat = lerp(this.initialColor.s, this.targetColor.s, t);
                 currentSat = Math.min(1, currentSat + midTransitionFactor * saturationPulse * snapFactor);
                 const currentLight = lerp(this.initialColor.l, this.targetColor.l, t);
                 this.currentColor = { h: currentHue, s: currentSat, l: currentLight };

                 const oneMinusT = 1 - t;
                 const baseX = oneMinusT * oneMinusT * this.initialX + 2 * oneMinusT * t * this.controlX + t * t * this.targetX;
                 const baseY = oneMinusT * oneMinusT * this.initialY + 2 * oneMinusT * t * this.controlY + t * t * this.targetY;

                 const maxVibration = vibrationMaxStrength * midTransitionFactor * this.depthFactor * snapFactor;
                 const randX = (Math.random() - 0.5) * maxVibration * 0.2; const randY = (Math.random() - 0.5) * maxVibration * 0.2;
                 this.vx += randX; this.vy += randY;
                 const damping = lerp(0.94, 0.88, t); this.vx *= damping; this.vy *= damping;
                 this.currentX = baseX + this.vx * snapFactor; this.currentY = baseY + this.vy * snapFactor;

                 if (this.isGlitching) { this.currentX += (Math.random() - 0.5) * glitchDisplacement; this.currentY += (Math.random() - 0.5) * glitchDisplacement; }

                 const movedX = this.currentX - this.prevX; const movedY = this.currentY - this.prevY;
                 this.currentSpeed = Math.sqrt(movedX * movedX + movedY * movedY);
                 const velocitySpin = this.currentSpeed * velocityRotationFactor * this.depthFactor * snapFactor;
                 this.rotation += this.rotationSpeed * (midTransitionFactor + 0.2) * snapFactor + velocitySpin;

                 // Trigger secondary burst for Entangled
                 if (Math.random() < burstProb && midTransitionFactor > 0.3 && !this.isGlitching) {
                    createBurst(this.currentX, this.currentY, hslToRgbString(this.currentColor.h, this.currentColor.s, this.currentColor.l, 0.5));
                 }
            }
            draw(ctx, progress, cssVars) {
                 const midTransitionFactor = Math.sin(Math.PI * progress); const t = easeInOutCubic(progress);
                 const { '--snap-threshold': snapThreshold, '--snap-power': snapPower, '--glitch-color': glitchColor, '--streak-opacity': streakOpacity, '--particle-glow-blur': particleGlowBlur } = cssVars;
                 const visualSnapFactor = progress > snapThreshold ? Math.max(0, 1 - Math.pow((progress - snapThreshold) / (1 - snapThreshold), snapPower * 0.8)) : 1.0;

                 let drawColorHsl = this.currentColor; let drawLength = this.length; let finalGlowOpacity = this.baseGlowOpacity * (0.5 + midTransitionFactor * 0.7) * visualSnapFactor;
                 if (this.isGlitching) { drawColorHsl = { h: (drawColorHsl.h + 180) % 360, s: Math.random() * 0.5 + 0.5, l: drawColorHsl.l }; finalGlowOpacity = 0.9; drawLength *= 1.5; }
                 const drawColorStr = hslToRgbString(drawColorHsl.h, drawColorHsl.s, drawColorHsl.l);

                 if (midTransitionFactor > 0.2 && this.currentSpeed > 0.5 && !this.isGlitching && Math.random() < 0.6) {
                     const streakAlpha = Math.min(1, this.currentSpeed * 0.5) * streakOpacity * visualSnapFactor * (1 - t);
                     if (streakAlpha > 0.03) {
                         ctx.save(); ctx.globalAlpha = streakAlpha; ctx.strokeStyle = drawColorStr; ctx.lineWidth = this.thickness * 0.7; ctx.lineCap = 'round';
                         ctx.beginPath(); ctx.moveTo(this.prevX, this.prevY);
                         const trailEndX = lerp(this.prevX, this.currentX, 0.5); const trailEndY = lerp(this.prevY, this.currentY, 0.5);
                         ctx.quadraticCurveTo(trailEndX, trailEndY, this.currentX, this.currentY);
                         ctx.stroke(); ctx.restore();
                     }
                 }

                 ctx.save();
                 const glowIntensity = (midTransitionFactor * 0.6 + 0.4) * this.depthFactor * visualSnapFactor;
                 const finalBlur = particleGlowBlur * glowIntensity * (this.isGlitching ? 1.3 : 1);
                 if (finalBlur > 0.5) {
                    const glowColor = hslToRgbString(drawColorHsl.h, Math.min(1, drawColorHsl.s * 1.2), Math.min(0.8, drawColorHsl.l * 1.1), finalGlowOpacity * glowIntensity);
                    ctx.shadowColor = glowColor; ctx.shadowBlur = finalBlur;
                 } else { ctx.shadowBlur = 0; }

                 ctx.translate(this.currentX, this.currentY); ctx.rotate(this.rotation); ctx.fillStyle = drawColorStr;
                 const r = this.radius; const halfLength = drawLength / 2; const halfThickness = this.thickness / 2;
                 ctx.beginPath(); ctx.moveTo(-halfLength + r, -halfThickness);
                 ctx.arcTo( halfLength, -halfThickness,  halfLength,  halfThickness, r); ctx.arcTo( halfLength,  halfThickness, -halfLength,  halfThickness, r);
                 ctx.arcTo(-halfLength,  halfThickness, -halfLength, -halfThickness, r); ctx.arcTo(-halfLength, -halfThickness,  halfLength, -halfThickness, r);
                 ctx.closePath(); ctx.fill(); ctx.restore();
            }
        }

        function drawEntangledGrid(ctx, progress, cssVars) { // Now accepts context
              const midTransitionFactor = Math.sin(Math.PI * progress);
              if (midTransitionFactor < 0.05) return;
              const gridColor = cssVars['--grid-color']; let gridSpacing = cssVars['--grid-spacing'];
              const gridWarpIntensity = cssVars['--grid-warp-intensity'];

              ctx.save(); ctx.lineWidth = 0.5;
              const pulseFactor = 0.1 * Math.sin(progress * Math.PI * 4); gridSpacing *= (1 + pulseFactor);
              const dynamicWarp = gridWarpIntensity * (0.8 + 0.4 * Math.sin(progress * Math.PI * 1.5));
              ctx.strokeStyle = gridColor.replace(/[\d\.]+\)$/g, `${(midTransitionFactor * 0.6 + 0.1).toFixed(3)})`);

              const warpFrequency = 0.035 * Math.PI * 2; const timeOffset = performance.now() * 0.0005;
              const step = gridSpacing > 35 ? 12 : 6;

              ctx.beginPath();
              for (let x = gridSpacing / 2; x < transitionCanvas.width + gridSpacing; x += gridSpacing) {
                  ctx.moveTo(x + Math.sin(0 * warpFrequency + timeOffset + x*0.01) * dynamicWarp, -gridSpacing);
                  for (let y = -gridSpacing + step; y < transitionCanvas.height + gridSpacing; y += step) {
                      ctx.lineTo(x + Math.sin(y * warpFrequency + timeOffset + x*0.01) * dynamicWarp, y);
                  }
              }
              for (let y = gridSpacing / 2; y < transitionCanvas.height + gridSpacing; y += gridSpacing) {
                  ctx.moveTo(-gridSpacing, y + Math.cos(0 * warpFrequency + timeOffset + y*0.01) * dynamicWarp);
                  for (let x = -gridSpacing + step; x < transitionCanvas.width + gridSpacing; x += step) {
                       ctx.lineTo(x, y + Math.cos(x * warpFrequency + timeOffset + y*0.01) * dynamicWarp);
                  }
              }
              ctx.stroke(); ctx.restore();
        }

        function setupEntangledEffect(fromSection, toSection) {
             document.documentElement.style.setProperty('--transition-duration', `${entangledTransitionDuration}ms`);
             resizeTransitionCanvas();
             transitionCanvas.style.backgroundColor = 'transparent';
             transitionCanvas.style.mixBlendMode = 'screen';
             transitionCanvas.style.display = 'block';
             updatePageGlow(toSection);

             const cssVars = cacheCSSVars(entangledCSSVarNames);
             const particleBaseLength = cssVars['--particle-base-length'];
             const particleBaseThickness = cssVars['--particle-base-thickness'];
             const rotationSpeedFactor = cssVars['--rotation-speed-factor'];

             const outgoingPixelData = getTextPixelData(fromSection, particleBaseLength, particleBaseThickness, entangledParticleDensity, entangledMaxParticles);
             const incomingPixelData = getTextPixelData(toSection, particleBaseLength, particleBaseThickness, entangledParticleDensity, entangledMaxParticles);

             if (outgoingPixelData.length === 0) { console.warn("Entangled: Outgoing generation failed."); completeTransition(false); return; }

             entangledParticles = outgoingPixelData.map(p => new EntangledParticle(p.x, p.y, p.color, cssVars));
             const numParticles = entangledParticles.length;
             const hasIncomingData = incomingPixelData.length > 0;

             for (let i = 0; i < numParticles; i++) {
                 const particle = entangledParticles[i]; const pairIndex = numParticles - 1 - i;
                 const pairedParticle = (i !== pairIndex && pairIndex >= 0 && pairIndex < numParticles) ? entangledParticles[pairIndex] : null;
                 let targetData, targetColorHex;
                 if (hasIncomingData) { targetData = incomingPixelData[i % incomingPixelData.length]; targetColorHex = targetData.color; }
                 else { const fallbackColors = toSection.querySelector('.section-data').dataset; targetData = { x: particle.initialX, y: particle.initialY }; targetColorHex = i % 2 === 0 ? (fallbackColors.color1 || '#ddff99') : (fallbackColors.color2 || '#bbdd77'); }
                 particle.assignTarget(targetData.x, targetData.y, targetColorHex, cssVars);

                 if (!particle.isPaired) {
                      const speed = (Math.random() - 0.5) * rotationSpeedFactor * 2.0; const hueDir = Math.random() > 0.5 ? 1 : -1;
                      particle.setPairProperties(speed, hueDir);
                      if (pairedParticle && !pairedParticle.isPaired) { pairedParticle.setPairProperties(-speed, -hueDir); }
                  }
             }
             if (!hasIncomingData) { console.warn("Entangled: Incoming generation failed. Morphing color/position only."); }

             transitionStartTime = 0; secondaryBursts = []; // Clear bursts
             if (transitionAnimationFrameId) cancelAnimationFrame(transitionAnimationFrameId);
             currentFrameCSSVars = cssVars;
             transitionAnimationFrameId = requestAnimationFrame(animateEntangled);
         }

        function animateEntangled(timestamp) {
             if (!transitionStartTime) transitionStartTime = timestamp;
             const elapsed = timestamp - transitionStartTime;
             let progress = Math.min(elapsed / entangledTransitionDuration, 1);

             const cssVars = currentFrameCSSVars;

             transitionCtx.clearRect(0, 0, transitionCanvas.width, transitionCanvas.height);
             drawEntangledGrid(transitionCtx, progress, cssVars); // Pass context

             for (let i = 0; i < entangledParticles.length; i++) {
                 const p = entangledParticles[i];
                 p.update(progress, cssVars);
                 p.draw(transitionCtx, progress, cssVars); // Pass context
             }
             drawBursts(transitionCtx); // Draw secondary bursts on top for Entangled

             transitionCtx.shadowBlur = 0; transitionCtx.shadowColor = 'transparent'; transitionCtx.globalAlpha = 1.0;

             if (progress < 1) {
                 transitionAnimationFrameId = requestAnimationFrame(animateEntangled);
             } else {
                 completeTransition();
             }
         }


        // --- EFFECT 2: Spin Transition ---
        let spinParticles = [];
        const spinTransitionDuration = 1700;
        const spinParticleDensity = 0.7;
        const spinMaxParticles = 7000;
        let spinPulseActive = false;

        // CSS Vars used by Spin (Burst probability can be removed if desired)
        const spinCSSVarNames = [
             '--rotation-speed-factor', '--vibration-max-strength', '--particle-length',
             '--particle-thickness', '--ghost-opacity', '--particle-glow-blur', '--particle-glow-opacity',
             '--spin-pulse-color', '--secondary-burst-probability' // Kept here for now, but not used in update
        ];

        class SpinParticle {
            constructor(x, y, color, cssVars) {
                 this.initialX = x; this.initialY = y; this.initialColor = color; // Store RGB string
                 this.currentX = x; this.currentY = y; this.currentColor = color;
                 this.targetX = x; this.targetY = y; this.targetColor = color;
                 this.vx = 0; this.vy = 0; this.travelDistance = 0; this.rotation = Math.random() * Math.PI * 2;
                 this.rotationSpeed = (Math.random() - 0.5) * cssVars['--rotation-speed-factor'] * 1.2;
                 this.prevX = x; this.prevY = y;
                 this.baseLength = cssVars['--particle-length'];
                 this.baseThickness = cssVars['--particle-thickness'];
                 this.radius = this.baseThickness / 3;
            }
            assignTarget(targetX, targetY, targetColor) { this.targetX = targetX; this.targetY = targetY; this.targetColor = targetColor; const dx = this.initialX - this.targetX; const dy = this.initialY - this.targetY; this.travelDistance = Math.sqrt(dx * dx + dy * dy); }
            update(progress, cssVars) { // Burst trigger REMOVED
                 this.prevX = this.currentX; this.prevY = this.currentY;
                 const t = easeInOutCubic(progress);
                 const { '--vibration-max-strength': vibrationMaxStrength /*, '--secondary-burst-probability': burstProb */ } = cssVars; // Burst prob commented out

                 this.currentColor = lerpColorRGB(this.initialColor, this.targetColor, t);
                 const baseX = lerp(this.initialX, this.targetX, t); const baseY = lerp(this.initialY, this.targetY, t);
                 const midTransitionFactor = Math.sin(Math.PI * progress);
                 const displaceAngle = Math.atan2(this.initialY - this.targetY, this.initialX - this.targetX) + Math.PI / 2;
                 const maxDisplace = 60;
                 const actualDisplace = maxDisplace * midTransitionFactor * Math.min(1, this.travelDistance / 250);
                 const displaceX = Math.cos(displaceAngle) * actualDisplace * (Math.random() * 0.5 + 0.75);
                 const displaceY = Math.sin(displaceAngle) * actualDisplace * (Math.random() * 0.5 + 0.75);

                 const vibrationStrength = vibrationMaxStrength * midTransitionFactor * 0.9;
                 this.vx += (Math.random() - 0.5) * vibrationStrength * 0.18; this.vy += (Math.random() - 0.5) * vibrationStrength * 0.18;
                 const damping = lerp(0.95, 0.89, t * t); this.vx *= damping; this.vy *= damping;

                 this.currentX = baseX + displaceX + this.vx; this.currentY = baseY + displaceY + this.vy;
                 this.rotation += this.rotationSpeed * (midTransitionFactor * 2.0 + 0.1);

                  // REMOVED: Trigger secondary burst for Spin
                  /*
                  if (Math.random() < burstProb && midTransitionFactor > 0.4) {
                     createBurst(this.currentX, this.currentY, this.currentColor.replace('rgb', 'rgba').replace(')', ', 0.4)'));
                  }
                  */
            }
             draw(ctx, progress, cssVars) { // No changes needed in draw
                  const midTransitionFactor = Math.sin(Math.PI * progress); const t = easeInOutCubic(progress);
                  const ghostOpacity = cssVars['--ghost-opacity']; const particleLength = this.baseLength * (1 + Math.sin(progress * Math.PI * 3) * 0.1);
                  const particleThickness = this.baseThickness; const particleGlowBlur = cssVars['--particle-glow-blur']; const particleGlowOpacity = cssVars['--particle-glow-opacity'];

                  if (midTransitionFactor > 0.5 && Math.random() < 0.5) {
                      const ghostProgress = (progress - 0.5) * 2; const ghostAlpha = midTransitionFactor * ghostOpacity * (1 - ghostProgress * 0.8);
                      if (ghostAlpha > 0.02) {
                          ctx.save(); ctx.globalAlpha = ghostAlpha; ctx.translate(this.prevX, this.prevY); ctx.rotate(this.rotation - this.rotationSpeed * 3); ctx.fillStyle = this.currentColor;
                          const r = this.radius; const halfLength = particleLength / 2; const halfThickness = particleThickness / 2;
                          ctx.beginPath(); ctx.moveTo(-halfLength + r, -halfThickness);
                          ctx.arcTo( halfLength, -halfThickness,  halfLength,  halfThickness, r); ctx.arcTo( halfLength,  halfThickness, -halfLength,  halfThickness, r);
                          ctx.arcTo(-halfLength,  halfThickness, -halfLength, -halfThickness, r); ctx.arcTo(-halfLength, -halfThickness,  halfLength, -halfThickness, r);
                          ctx.closePath(); ctx.fill(); ctx.restore();
                      }
                  }

                  ctx.save();
                  const glowIntensity = (midTransitionFactor * 0.7 + 0.3) * particleGlowOpacity;
                  if (glowIntensity > 0.05) {
                     const finalBlur = particleGlowBlur * (midTransitionFactor * 0.8 + 0.2);
                     if (finalBlur > 0.5) { const glowColor = this.currentColor.replace('rgb', 'rgba').replace(')', `, ${glowIntensity * 0.8})`); ctx.shadowColor = glowColor; ctx.shadowBlur = finalBlur; }
                     else { ctx.shadowBlur = 0; }
                  } else { ctx.shadowBlur = 0; }

                  ctx.translate(this.currentX, this.currentY); ctx.rotate(this.rotation); ctx.fillStyle = this.currentColor;
                  const r = this.radius; const halfLength = particleLength / 2; const halfThickness = particleThickness / 2;
                  ctx.beginPath(); ctx.moveTo(-halfLength + r, -halfThickness);
                  ctx.arcTo( halfLength, -halfThickness,  halfLength,  halfThickness, r); ctx.arcTo( halfLength,  halfThickness, -halfLength,  halfThickness, r);
                  ctx.arcTo(-halfLength,  halfThickness, -halfLength, -halfThickness, r); ctx.arcTo(-halfLength, -halfThickness,  halfLength, -halfThickness, r);
                  ctx.closePath(); ctx.fill(); ctx.restore();
             }
         }

        function setupSpinEffect(fromSection, toSection) {
            document.documentElement.style.setProperty('--transition-duration', `${spinTransitionDuration}ms`);
            resizeTransitionCanvas();
            transitionCanvas.style.backgroundColor = 'transparent';
            transitionCanvas.style.mixBlendMode = 'screen';
            transitionCanvas.style.display = 'block';
            updatePageGlow(toSection);
            spinPulseActive = true;

            const cssVars = cacheCSSVars(spinCSSVarNames);
            const particleLength = cssVars['--particle-length'];
            const particleThickness = cssVars['--particle-thickness'];

            const outgoingPixelData = getTextPixelData(fromSection, particleLength, particleThickness, spinParticleDensity, spinMaxParticles);
            const incomingPixelData = getTextPixelData(toSection, particleLength, particleThickness, spinParticleDensity, spinMaxParticles);

            if (outgoingPixelData.length === 0) { console.warn("Spin: Outgoing generation failed."); completeTransition(false); return; }

            spinParticles = outgoingPixelData.map(p => new SpinParticle(p.x, p.y, p.color, cssVars));
            const hasIncomingData = incomingPixelData.length > 0;

            spinParticles.forEach((particle, index) => {
                let targetData, targetColor;
                 if (hasIncomingData) { targetData = incomingPixelData[index % incomingPixelData.length]; targetColor = targetData.color; }
                 else { const fallbackColors = toSection.querySelector('.section-data').dataset; targetData = { x: particle.initialX, y: particle.initialY }; targetColor = index % 2 === 0 ? (fallbackColors.color1 || '#ddff55') : (fallbackColors.color2 || '#bbcc33'); }
                 particle.assignTarget(targetData.x, targetData.y, targetColor);
             });
            if (!hasIncomingData) { console.warn("Spin: Incoming generation failed. Morphing color only."); }

            transitionStartTime = 0; secondaryBursts = []; // Clear bursts array (precaution)
            if (transitionAnimationFrameId) cancelAnimationFrame(transitionAnimationFrameId);
            currentFrameCSSVars = cssVars;
            transitionAnimationFrameId = requestAnimationFrame(animateSpin);
        }

        function drawSpinPulse(ctx, progress, cssVars) { // Now accepts context
             if (!spinPulseActive) return;
             const pulseDurationFraction = 0.15;
             if (progress > pulseDurationFraction) { spinPulseActive = false; return; }

             const pulseProgress = progress / pulseDurationFraction;
             const pulseEase = 1 - Math.pow(1 - pulseProgress, 3);
             const maxRadius = Math.min(transitionCanvas.width, transitionCanvas.height) * 0.4;
             const currentRadius = maxRadius * pulseEase;
             const currentOpacity = (1 - pulseEase) * 0.8;

             if (currentOpacity > 0.01) {
                 ctx.save(); ctx.beginPath(); ctx.arc(transitionCanvas.width / 2, transitionCanvas.height / 2, currentRadius, 0, Math.PI * 2);
                 ctx.fillStyle = cssVars['--spin-pulse-color'].replace(/[\d\.]+\)$/g, `${currentOpacity.toFixed(3)})`);
                 ctx.fill(); ctx.restore();
             }
        }

        function animateSpin(timestamp) { // drawBursts call REMOVED
            if (!transitionStartTime) transitionStartTime = timestamp;
            const elapsed = timestamp - transitionStartTime;
            let progress = Math.min(elapsed / spinTransitionDuration, 1);
            const cssVars = currentFrameCSSVars;

            transitionCtx.clearRect(0, 0, transitionCanvas.width, transitionCanvas.height);
            drawSpinPulse(transitionCtx, progress, cssVars); // Pass context

            // Update and draw particles
            for (let i = 0; i < spinParticles.length; i++) {
                 const p = spinParticles[i];
                 p.update(progress, cssVars);
                 p.draw(transitionCtx, progress, cssVars); // Pass context
             }
            // drawBursts(transitionCtx); // <<<< REMOVED for Spin transition

            // Reset canvas state
            transitionCtx.shadowBlur = 0;
            transitionCtx.shadowColor = 'transparent';
            transitionCtx.globalAlpha = 1.0;

            if (progress < 1) {
                transitionAnimationFrameId = requestAnimationFrame(animateSpin);
            } else {
                spinPulseActive = false; // Ensure pulse is deactivated at the end
                completeTransition();
            }
        }


        // --- EFFECT 3: Decoherence Transition ---
        const decoherenceDataStreamOverlay = document.getElementById('data-stream-overlay');
        let decoherenceTextCorruptionInterval = null;
        let decoherenceTransitionTimeout = null;

        const decoherenceCSSVarNames = [
             '--deco-glitch-duration', '--deco-burst-duration', '--deco-settle-duration',
             '--deco-ghost-duration', '--corruption-interval', '--corruption-rate', '--corruption-char-pool',
             '--deco-chromatic-offset'
         ];

        function setupDecoherenceEffect(fromSection, toSection) {
            const cssVars = cacheCSSVars(decoherenceCSSVarNames);
            const glitchDuration = cssVars['--deco-glitch-duration'];
            const burstDuration = cssVars['--deco-burst-duration'];
            const settleDuration = cssVars['--deco-settle-duration'];
            const ghostDuration = cssVars['--deco-ghost-duration'];
            const corruptionIntervalMs = cssVars['--corruption-interval'];
            const corruptionRate = cssVars['--corruption-rate'];
            const corruptionPool = cssVars['--corruption-char-pool'];

            transitionCanvas.style.display = 'none'; // Hide transition canvas
            updatePageGlow(toSection, true);

            body.classList.add('transitioning-decoherence');
            blockFlashOverlay.classList.add('active'); // Activate block flash
            fromSection.classList.add('glitching');
            fromSection.style.zIndex = 1; toSection.style.zIndex = 2;

            const elementsToCorrupt = fromSection.querySelectorAll('[data-original-text]');
            if (decoherenceTextCorruptionInterval) clearInterval(decoherenceTextCorruptionInterval);
            if (!prefersReducedMotion) { // Only corrupt if not reduced motion
                decoherenceTextCorruptionInterval = setInterval(() => {
                    elementsToCorrupt.forEach(el => corruptText(el, corruptionPool, corruptionRate));
                }, corruptionIntervalMs);
            }

            if (decoherenceTransitionTimeout) clearTimeout(decoherenceTransitionTimeout);
            const snapTime = glitchDuration - (burstDuration * 0.4);

            decoherenceTransitionTimeout = setTimeout(() => {
                if (decoherenceTextCorruptionInterval) clearInterval(decoherenceTextCorruptionInterval);
                decoherenceTextCorruptionInterval = null;
                restoreText(fromSection); // Restore before ghosting

                blockFlashOverlay.classList.remove('active'); // Deactivate block flash
                toSection.classList.add('active', 'settling');
                restoreText(toSection);

                fromSection.classList.remove('glitching');
                fromSection.classList.add('ghosting');

                setTimeout(() => { toSection.classList.remove('settling'); }, settleDuration);

                setTimeout(() => {
                    fromSection.classList.remove('active', 'ghosting');
                    fromSection.style.zIndex = 1; fromSection.style.transform = ''; fromSection.style.clipPath = ''; fromSection.style.filter = ''; fromSection.style.color = '';
                    body.classList.remove('transitioning-decoherence');
                    completeTransition();
                }, ghostDuration);

            }, snapTime);
        }

        // Decoherence Text Helpers
        function setupTextData() {
             const decoSections = document.querySelectorAll('#section-decoherence-1, #section-decoherence-2');
             decoSections.forEach(section => {
                 const elementsWithText = section.querySelectorAll('h1, p, .nav-button');
                 elementsWithText.forEach(el => {
                    if (el && !el.hasAttribute('data-original-text')) {
                        const text = el.textContent?.trim() || '';
                        el.setAttribute('data-original-text', text);
                    }
                 });
             });
         }
        function corruptText(element, pool, rate) {
            if (!element || !pool) return;
            const originalChars = element.getAttribute('data-original-text')?.split('');
            if (!originalChars || originalChars.length === 0) return;
            const len = originalChars.length; let output = ''; const poolChars = pool; const poolLen = poolChars.length;
            if (poolLen === 0) { if (element.textContent !== element.getAttribute('data-original-text')) { element.textContent = element.getAttribute('data-original-text'); } return; }
            for (let i = 0; i < len; i++) { const char = originalChars[i]; if (char === ' ' || Math.random() > rate) { output += char; } else { output += poolChars[Math.floor(Math.random() * poolLen)]; } }
            element.textContent = output;
        }
        function restoreText(section) {
            if (!section) return;
            const elementsWithText = section.querySelectorAll('[data-original-text]');
            elementsWithText.forEach(el => { const original = el.getAttribute('data-original-text'); if (original !== null && el.textContent !== original) { el.textContent = original; } });
        }
        function generateDataStreamContent(overlayElement, lines = 50, cols = 100) {
             let content = ''; const pool = getComputedStyle(document.documentElement).getPropertyValue('--corruption-char-pool').trim() || "01"; const chars = Array.from(pool.replace(/[█▓▒░ "]/g,'')); if (chars.length === 0) chars.push('0','1');
             for (let i = 0; i < lines * 2; i++) { for (let j = 0; j < cols; j++) { content += chars[Math.floor(Math.random() * chars.length)]; } content += '\n'; }
             overlayElement.textContent = content;
         }
         function generateBlockFlashContent(overlayElement) { // Generate content for block flash overlay
             let content = '';
             const chars = ['█', '▓', '▒', '░', ' ']; // Characters to flash
             const rows = Math.ceil(window.innerHeight / 16); // Estimate rows based on font size
             const cols = Math.ceil(window.innerWidth / 9); // Estimate columns based on font size
             for (let i = 0; i < rows; i++) {
                 for (let j = 0; j < cols; j++) {
                     content += chars[Math.floor(Math.random() * chars.length)];
                 }
                 content += '\n';
             }
             overlayElement.textContent = content;
         }

        // --- Master Transition Control ---
        function triggerMasterTransition(direction) {
            if (isAnimating) return;

            // Stop idle animations immediately
            if (idleAnimationFrameId) cancelAnimationFrame(idleAnimationFrameId);
            idleAnimationFrameId = null;
             // Also remove idle CSS classes from text elements if active
            const currentlyActive = document.querySelector('.section.active');
            if (currentlyActive) {
                currentlyActive.querySelectorAll('h1, p').forEach(el => el.style.animation = 'none'); // Quick way to stop CSS anim
            }


            isAnimating = true; // Set transition flag

            const currentEffectSections = sectionsPerEffect[currentEffectIndex];
            const currentActiveSection = currentEffectSections[currentSectionIndexInEffect];

            let nextEffectIndex = currentEffectIndex; let nextSectionIndexInEffect = currentSectionIndexInEffect;

            if (direction === 'down') {
                 nextSectionIndexInEffect++;
                 if (nextSectionIndexInEffect >= currentEffectSections.length) { nextEffectIndex = (currentEffectIndex + 1) % totalEffects; nextSectionIndexInEffect = 0; }
            } else {
                 nextSectionIndexInEffect--;
                 if (nextSectionIndexInEffect < 0) { nextEffectIndex = (currentEffectIndex - 1 + totalEffects) % totalEffects; nextSectionIndexInEffect = sectionsPerEffect[nextEffectIndex].length - 1; }
            }

            if (nextEffectIndex === currentEffectIndex && nextSectionIndexInEffect === currentSectionIndexInEffect) {
                isAnimating = false;
                startIdleAnimations(); // No change, restart idle
                // Re-apply idle animation styles if needed
                 if (currentlyActive) {
                    currentlyActive.querySelectorAll('h1, p').forEach(el => el.style.animation = ''); // Restore CSS anim
                 }
                return;
            }

            const nextEffectSections = sectionsPerEffect[nextEffectIndex];
            const nextActiveSection = nextEffectSections[nextSectionIndexInEffect];
            const effectType = effectTypes[nextEffectIndex];

            currentActiveSection.classList.remove('active'); // Visually deactivate

            switch(effectType) {
                case 'system': setupSystemEffect(currentActiveSection, nextActiveSection); break;
                case 'entangled': setupEntangledEffect(currentActiveSection, nextActiveSection); break;
                case 'spin': setupSpinEffect(currentActiveSection, nextActiveSection); break;
                case 'decoherence':
                    currentEffectIndex = nextEffectIndex; currentSectionIndexInEffect = nextSectionIndexInEffect; // Update indices before async call
                    setupDecoherenceEffect(currentActiveSection, nextActiveSection);
                    return; // Decoherence handles its own completion
                default:
                     console.error("Unknown effect type:", effectType); isAnimating = false; currentActiveSection.classList.add('active'); updatePageGlow(currentActiveSection); startIdleAnimations(); return;
            }
            currentEffectIndex = nextEffectIndex; currentSectionIndexInEffect = nextSectionIndexInEffect;
        }

        // --- Page Glow Update Helper ---
        function updatePageGlow(targetSection, immediate = false) {
            if (!targetSection) return;
            const colorElement = targetSection.querySelector('.system-colors') || targetSection.querySelector('.section-data');
            let glowColor = getComputedStyle(document.documentElement).getPropertyValue('--page-glow-color').trim();
            if (colorElement && colorElement.dataset.glow) { glowColor = colorElement.dataset.glow; }
            else if (colorElement && colorElement.dataset.color1) { try { const [r, g, b] = parseHexColor(colorElement.dataset.color1); glowColor = `rgba(${r}, ${g}, ${b}, 0.6)`; } catch (e) {} }
            else if (targetSection.id.includes('decoherence')) { glowColor = 'rgba(0, 187, 255, 0.6)'; }

            const glowElement = document.body;
            if (immediate) glowElement.style.transition = 'none';
            glowElement.style.setProperty('--page-glow-color', glowColor);
            if (immediate) { glowElement.offsetHeight; requestAnimationFrame(() => { glowElement.style.transition = ''; }); }
        }


        // --- Complete Transition (Robust Cleanup) ---
        function completeTransition(showNext = true) {
            if (transitionAnimationFrameId) cancelAnimationFrame(transitionAnimationFrameId);
            transitionAnimationFrameId = null;

            transitionCanvas.style.display = 'none'; transitionCanvas.style.backgroundColor = 'transparent'; transitionCanvas.style.mixBlendMode = 'screen';
            systemParticles = []; entangledParticles = []; spinParticles = []; secondaryBursts = [];
            currentFrameCSSVars = {}; spinPulseActive = false;
            if (decoherenceTextCorruptionInterval) clearInterval(decoherenceTextCorruptionInterval); decoherenceTextCorruptionInterval = null;
            if (decoherenceTransitionTimeout) clearTimeout(decoherenceTransitionTimeout); decoherenceTransitionTimeout = null;
            body.classList.remove('transitioning-decoherence');
            blockFlashOverlay.classList.remove('active'); // Ensure block flash is off

            const finalActiveSection = sectionsPerEffect[currentEffectIndex]?.[currentSectionIndexInEffect];

            allSections.forEach(s => {
                s.classList.remove('active', 'glitching', 'ghosting', 'settling');
                s.style.transform = ''; s.style.clipPath = ''; s.style.filter = ''; s.style.color = '';
                restoreText(s);
                 // Ensure idle CSS animations are stopped/reset on all sections after transition
                s.querySelectorAll('h1, p').forEach(el => el.style.animation = '');
            });

            if (showNext && finalActiveSection) { finalActiveSection.classList.add('active'); updatePageGlow(finalActiveSection, true); }
            else if (!showNext && finalActiveSection) { finalActiveSection.classList.add('active'); updatePageGlow(finalActiveSection, true); }
            else { console.error("Target section not found on completion, activating first section."); allSections[0]?.classList.add('active'); updatePageGlow(allSections[0], true); }

            isAnimating = false; // Allow new transitions
            transitionStartTime = 0;
            startIdleAnimations(); // Restart idle animations for the new active section
        }

        // --- Utility & Setup ---
        function resizeCanvases() { // Resizes both canvases
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;

            let resized = false;
            if (transitionCanvas.width !== newWidth || transitionCanvas.height !== newHeight) {
                transitionCanvas.width = newWidth; transitionCanvas.height = newHeight;
                backgroundCanvas.width = newWidth; backgroundCanvas.height = newHeight; // Keep them same size
                resized = true;
            }

            if (resized) {
                 const widthChange = Math.abs(newWidth - lastCanvasWidth);
                 const heightChange = Math.abs(newHeight - lastCanvasHeight);
                 const significantResizeThreshold = 50;
                 if (widthChange > significantResizeThreshold || heightChange > significantResizeThreshold || lastCanvasWidth === 0) {
                     textPixelDataCache.clear(); lastCanvasWidth = 0; lastCanvasHeight = 0;
                     // Reinitialize background particles on significant resize
                     initBgParticles();
                     // Regenerate block flash content for new size
                     generateBlockFlashContent(blockFlashOverlay);
                 }
            }
        }
        // Specific resizer for transition canvas only (used before text sampling)
        function resizeTransitionCanvas() {
             const newWidth = window.innerWidth; const newHeight = window.innerHeight;
             if (transitionCanvas.width !== newWidth || transitionCanvas.height !== newHeight) {
                 transitionCanvas.width = newWidth; transitionCanvas.height = newHeight;
                 // No need to clear cache here, getTextPixelData handles it
             }
        }
        window.addEventListener('resize', resizeCanvases);

        // Interaction Handling
        let lastInteractionTime = 0; const interactionThrottle = 350;
        const handleInteraction = (direction) => { const now = Date.now(); if (!isAnimating && now - lastInteractionTime > interactionThrottle) { lastInteractionTime = now; triggerMasterTransition(direction); } };
        window.addEventListener('wheel', (event) => { if (Math.abs(event.deltaY) > 10) { handleInteraction(event.deltaY > 0 ? 'down' : 'up'); } }, { passive: true });
        window.addEventListener('keydown', (event) => { let direction = null; if (['ArrowDown', 'PageDown', ' ', 'ArrowRight'].includes(event.key)) direction = 'down'; else if (['ArrowUp', 'PageUp', 'ArrowLeft'].includes(event.key)) direction = 'up'; if (direction) { event.preventDefault(); handleInteraction(direction); } });
        let touchStartY = 0; let touchDidMove = false;
        window.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { touchStartY = e.touches[0].clientY; touchDidMove = false; } }, { passive: true });
        window.addEventListener('touchmove', (e) => { if (e.touches.length === 1 && Math.abs(e.touches[0].clientY - touchStartY) > 10) { touchDidMove = true; } }, { passive: true });
        window.addEventListener('touchend', (e) => { if (e.changedTouches.length === 1 && touchDidMove) { const touchEndY = e.changedTouches[0].clientY; const swipeThreshold = 40; if (Math.abs(touchEndY - touchStartY) > swipeThreshold) { handleInteraction(touchEndY < touchStartY ? 'down' : 'up'); } } touchStartY = 0; touchDidMove = false; }, { passive: true });
        mainElement.addEventListener('click', (event) => { if (event.target.matches('.nav-button') && !isAnimating) { const targetId = event.target.dataset.target; if (targetId) { let targetEffectIndex = -1; let targetSectionIndex = -1; sectionsPerEffect.forEach((group, eIndex) => group.forEach((sec, sIndex) => { if (sec.id === targetId.substring(1)) { targetEffectIndex = eIndex; targetSectionIndex = sIndex; } })); if (targetEffectIndex !== -1 && targetSectionIndex !== -1) { const direction = (targetSectionIndex > currentSectionIndexInEffect) ? 'down' : 'up'; handleInteraction(direction); } } } });

        // --- NEW Idle Animation Logic ---
        function initBgParticles() {
            bgParticles = [];
            for (let i = 0; i < NUM_BG_PARTICLES; i++) {
                bgParticles.push({
                    x: Math.random() * backgroundCanvas.width,
                    y: Math.random() * backgroundCanvas.height,
                    vx: (Math.random() - 0.5) * BG_PARTICLE_SPEED * 2,
                    vy: (Math.random() - 0.5) * BG_PARTICLE_SPEED * 2,
                    alpha: Math.random() * 0.3 + 0.1 // Random initial alpha
                });
            }
        }

        function drawBgParticles() {
             bgCtx.fillStyle = `rgba(180, 200, 255, ${prefersReducedMotion ? 0.1 : 0.3})`; // Base color
             bgParticles.forEach(p => {
                 p.x += p.vx; p.y += p.vy;
                 p.alpha += (Math.random() - 0.5) * 0.01; // Subtle alpha flicker
                 p.alpha = Math.max(0.05, Math.min(0.4, p.alpha)); // Clamp alpha

                 // Wrap around edges
                 if (p.x < -BG_PARTICLE_SIZE) p.x = backgroundCanvas.width + BG_PARTICLE_SIZE;
                 if (p.x > backgroundCanvas.width + BG_PARTICLE_SIZE) p.x = -BG_PARTICLE_SIZE;
                 if (p.y < -BG_PARTICLE_SIZE) p.y = backgroundCanvas.height + BG_PARTICLE_SIZE;
                 if (p.y > backgroundCanvas.height + BG_PARTICLE_SIZE) p.y = -BG_PARTICLE_SIZE;

                 bgCtx.globalAlpha = p.alpha;
                 bgCtx.beginPath();
                 bgCtx.arc(p.x, p.y, BG_PARTICLE_SIZE, 0, Math.PI * 2);
                 bgCtx.fill();
             });
             bgCtx.globalAlpha = 1.0; // Reset global alpha
        }

        function drawCursorTrail() {
             if (prefersReducedMotion) return; // Skip if reduced motion

             // Add new particle at current mouse position
             cursorTrailParticles.push({ x: mousePos.x, y: mousePos.y, alpha: 0.6 });

             // Remove oldest particles if trail is too long
             while (cursorTrailParticles.length > CURSOR_TRAIL_LENGTH) {
                 cursorTrailParticles.shift();
             }

             // Draw and fade out existing particles
             bgCtx.lineWidth = 1;
             bgCtx.strokeStyle = 'rgba(200, 220, 255, 0.5)'; // Trail color

             for (let i = cursorTrailParticles.length - 1; i >= 0; i--) {
                 const p = cursorTrailParticles[i];
                 p.alpha -= CURSOR_TRAIL_FADEOUT;

                 if (p.alpha <= 0) {
                     cursorTrailParticles.splice(i, 1);
                     continue;
                 }

                 bgCtx.globalAlpha = p.alpha;
                 bgCtx.beginPath();
                 // Draw a simple dot or small line segment
                 bgCtx.arc(p.x, p.y, 1, 0, Math.PI * 2);
                 // Optional: connect to previous point for a line effect
                 // if(i > 0) { ctx.moveTo(cursorTrailParticles[i-1].x, cursorTrailParticles[i-1].y); ctx.lineTo(p.x, p.y); }
                 bgCtx.stroke();
             }
             bgCtx.globalAlpha = 1.0;
         }

        function drawIdleGrid() {
            if (prefersReducedMotion) return; // Skip if reduced motion

            // Read CSS vars needed for the idle grid
            const styles = getComputedStyle(document.documentElement);
            const gridColor = styles.getPropertyValue('--grid-color').trim() || 'rgba(100, 110, 160, 0.06)';
            let gridSpacing = parseFloat(styles.getPropertyValue('--grid-spacing').trim()) || 45;
            const gridWarpIntensity = parseFloat(styles.getPropertyValue('--idle-grid-warp-intensity').trim()) || 0.5; // Use idle warp
            const gridOpacity = parseFloat(styles.getPropertyValue('--idle-grid-opacity').trim()) || 0.04;


            bgCtx.save();
            bgCtx.lineWidth = 0.3; // Very thin lines
            bgCtx.strokeStyle = gridColor.replace(/[\d\.]+\)$/g, `${gridOpacity.toFixed(3)})`);

            const warpFrequency = 0.025 * Math.PI * 2; // Slower frequency
            const timeOffset = performance.now() * 0.00015; // Slower time offset
            const step = gridSpacing > 35 ? 16 : 8; // Larger step for performance

            bgCtx.beginPath();
            // Vertical lines (subtly warped)
            for (let x = gridSpacing / 2; x < backgroundCanvas.width + gridSpacing; x += gridSpacing) {
                bgCtx.moveTo(x + Math.sin(0 * warpFrequency + timeOffset + x*0.005) * gridWarpIntensity, -gridSpacing);
                for (let y = -gridSpacing + step; y < backgroundCanvas.height + gridSpacing; y += step) {
                    bgCtx.lineTo(x + Math.sin(y * warpFrequency + timeOffset + x*0.005) * gridWarpIntensity, y);
                }
            }
            // Horizontal lines (subtly warped)
            for (let y = gridSpacing / 2; y < backgroundCanvas.height + gridSpacing; y += gridSpacing) {
                bgCtx.moveTo(-gridSpacing, y + Math.cos(0 * warpFrequency + timeOffset + y*0.005) * gridWarpIntensity);
                for (let x = -gridSpacing + step; x < backgroundCanvas.width + gridSpacing; x += step) {
                     bgCtx.lineTo(x, y + Math.cos(x * warpFrequency + timeOffset + y*0.005) * gridWarpIntensity);
                }
            }
            bgCtx.stroke();
            bgCtx.restore();
        }


        // Main Idle Animation Loop
        function animateIdle() {
             if (isAnimating) { // Should not run if a transition is active
                 idleAnimationFrameId = null;
                 return;
             }

             bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);

             // Draw background elements if not reduced motion
             if (!prefersReducedMotion) {
                 drawBgParticles();
                 drawIdleGrid(); // Draw the subtle idle grid
                 drawCursorTrail();
             } else {
                  // Optionally draw a very simplified background if needed in reduced motion
             }


             idleAnimationFrameId = requestAnimationFrame(animateIdle);
        }

        // Function to start idle animations
        function startIdleAnimations() {
             if (!idleAnimationFrameId && !isAnimating) { // Only start if not already running and no transition
                // Re-apply idle CSS animations to the currently active section's text
                const activeSection = document.querySelector('.section.active');
                if (activeSection) {
                    activeSection.querySelectorAll('h1, p').forEach(el => el.style.animation = ''); // Remove potential inline style override
                }
                animateIdle();
             }
        }

        // Mouse Move Listener (Throttled) for Reactive Glow
        window.addEventListener('mousemove', (event) => {
            if (prefersReducedMotion) return; // Skip if reduced motion

            const now = Date.now();
            if (now - lastMouseUpdate > MOUSE_UPDATE_THROTTLE) {
                lastMouseUpdate = now;
                mousePos.x = event.clientX;
                mousePos.y = event.clientY;
                // Update CSS variables for background glow position
                requestAnimationFrame(() => {
                    document.documentElement.style.setProperty('--mouse-x', `${(mousePos.x / window.innerWidth * 100).toFixed(2)}%`);
                    document.documentElement.style.setProperty('--mouse-y', `${(mousePos.y / window.innerHeight * 100).toFixed(2)}%`);
                });
            }
        }, { passive: true });


        // --- Initial Setup ---
        resizeCanvases(); // Initial canvas sizes
        initBgParticles(); // Initialize background particles
        setupTextData(); // Store original text for Decoherence sections
        generateDataStreamContent(decoherenceDataStreamOverlay); // Populate data stream overlay
        generateBlockFlashContent(blockFlashOverlay); // Populate block flash overlay

        allSections.forEach((sec, index) => {
            sec.classList.toggle('active', index === 0);
            const button = sec.querySelector('.nav-button');
            if (button) button.style.display = (index === 0 && sec.id.includes('decoherence')) ? 'inline-block' : 'none';
        });

        lastCanvasWidth = transitionCanvas.width; lastCanvasHeight = transitionCanvas.height;
        updatePageGlow(allSections[0], true); // Set initial page glow instantly

        startIdleAnimations(); // Start the idle animation loop

        console.log("Quantum Transitions Suite Initialized (Enhanced V2 - Fixed Spin).", prefersReducedMotion ? "(Reduced Motion Enabled)" : "");

    </script>

</body>
</html>
